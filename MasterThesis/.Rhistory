# Create an array of k values (capital per worker)
k_vals <- seq(0, 100, length.out = 500)
# Calculate steady-state values for both savings rates
k_star_initial <- steady_state_k(s_initial, n, delta, alpha, rho)
k_star_new <- steady_state_k(s_new, n, delta, alpha, rho)
# Plotting the graph
plot(k_vals, steady_state_k(s_initial, n, delta, alpha, rho),
type = "l", col = "blue", lwd = 2,
xlab = "Capital per Worker (k)", ylab = "Steady-State Capital per Worker",
main = "Effect of Increase in Savings Rate on Steady-State Capital per Worker")
lines(k_vals, steady_state_k(s_new, n, delta, alpha, rho), col = "red", lwd = 2, lty = 2)
# Add legend
legend("topright", legend = c(paste("Savings Rate =", s_initial), paste("Savings Rate =", s_new)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Define parameters
s <- 0.2  # savings rate
n_initial <- 0.01  # initial population growth rate
n_new <- 0.05  # increased population growth rate
delta <- 0.05  # depreciation rate
alpha <- 0.3  # output elasticity of capital
rho <- 0.5  # CES parameter
# Define the steady-state capital function
steady_state_k <- function(s, n, delta, alpha, rho) {
A <- s / (n + delta)
B <- (alpha / (1 - alpha))^(1 / rho)
return((A * B)^(1 / (1 - alpha)))
}
# Calculate steady-state capital per worker for different population growth rates
k_vals <- seq(0, 100, length.out = 500)  # a range of values for capital per worker
# Calculate steady-state capital for initial and new population growth rates
steady_state_initial_n <- steady_state_k(s, n_initial, delta, alpha, rho)
steady_state_new_n <- steady_state_k(s, n_new, delta, alpha, rho)
# Plotting the effect of change in population growth rate on steady-state capital per worker
plot(k_vals, steady_state_initial_n * k_vals, type = "l", col = "blue", lwd = 2,
xlab = "Capital per Worker (k)", ylab = "Steady-State Capital per Worker",
main = "Effect of Increase in Population Growth Rate on Steady-State Capital per Worker")
lines(k_vals, steady_state_new_n * k_vals, col = "red", lwd = 2, lty = 2)
# Add legend
legend("topright", legend = c(paste("Population Growth Rate =", n_initial), paste("Population Growth Rate =", n_new)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Display grid
grid()
#
rm(list = ls())
rm()
rm(list=ls())
package.install("palmerpenguins")
package.install("palmerpenguins")
install.packages("palmerpenguins")
?palmerpenguins
??palmerpenguins
table(penguins$species)
?penguins
??penguins
head(palmerpenguins::penguins	)
?(palmerpenguins::penguins)
table(penguins$species)
table(palmerpenguins::penguins$species)
install.packages(c("gtsummary", "flextable", "ivo.table"))
install.packages(c("gtsummary", "flextable", "ivo.table"))
library(gtsummary)
tbl_summary(palmerpenguins::penguins[,"species"])
install.packages("gtsummary")
library(gtsummary)
tbl_summary(palmerpenguins::penguins[,"species"])
graph.new()
plot.new()
plot.new()
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=6, b=3)
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=6, b=3)
box()
abline(a=6, b=3)
plot.new()
#plot.window(xlim=c(0,1), ylim=c(0,1))
#abline(a=6, b=3)
box()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=6, b=3)
axis(1)
axis(2)
abline(a=6, b=3)
title(main="The Overall Title")
title(xlab="An x-axis label")
title(ylab="A y-axis label")
box()
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=6, b=3)
axis(1)
axis(2)
title(main="The Overall Title")
title(xlab="An x-axis label")
title(ylab="A y-axis label")
box()
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=6, b=3)
axis(1)
axis(2)
title(main="The Overall Title")
title(xlab="An x-axis label")
title(ylab="A y-axis label")
box()
abline(a=.5, b=.45)
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
abline(a=.5, b=.45)
axis(1)
axis(2)
title(main="The Overall Title")
title(xlab="An x-axis label")
title(ylab="A y-axis label")
box()
abline(a=0, b=.45)
plot.window(xlim=c(0,1), ylim=c(5,10))
plot.new()
plot.window(xlim=c(0,1), ylim=c(5,10))
abline(a=.5, b=.45)
abline(a=0, b=.45)
axis(1)
axis(2)
title(main="The Overall Title")
title(xlab="An x-axis label")
title(ylab="A y-axis label")
box()
plot.new()
plot.window(xlim=c(0,1), ylim=c(5,10))
axis(1)
axis(2)
abline(a=5, b=.45)
plot.window(xlim=c(0,1), ylim=c(1,10))
abline(a=5, b=.45)
abline(a=0, b=.45)
plot.new()
plot.window(xlim=c(0,1), ylim=c(1,10))
abline(a=5, b=.45)
abline(a=0, b=.45)
axis(1)
axis(2)
points(.4,5)
points(.4,6)
points(.4,6, pch=8)
# Install necessary packages if you haven't already
if(!require(quantmod)){install.packages("quantmod")}
if(!require(data.table)){install.packages("data.table")}
if(!require(dplyr)){install.packages("dplyr")} # For data manipulation
if(!require(lubridate)){install.packages("lubridate")} # For date handling
library(quantmod)
library(data.table)
library(dplyr)
library(lubridate)
download_stock_data <- function(symbol, start_date, end_date) {
tryCatch({
data <- getSymbols(symbol, from = start_date, to = end_date, auto.assign = FALSE)
if (is.null(data) || nrow(data) == 0) {
print(paste("No data found for symbol", symbol, "within the specified date range."))
return(NULL)
}
return(data)
}, error = function(e) {
print(paste("Error downloading data for", symbol, ":", e$message))
return(NULL)
})
}
## Get present location
LOC_CODE = dirname(rstudioapi::getSourceEditorContext()$path)
print(LOC_CODE)
## Set it as current working directory
setwd(LOC_CODE)
symbol1 <- "^NSEI" #"HDFCNIFETF.NS" # Example: SBI Nifty 50 ETF
symbol2 <- "BHARTIARTL.NS" #"NIFTY1.NS" # Example: Nippon India ETF Nifty 50 BeES
formation_start <- "2022-01-01"
formation_end <- "2022-12-31"
trading_start <- "2023-01-01"
trading_end <- "2023-06-30"
# 1. Download Data
stock1_data <- download_stock_data(symbol1, formation_start, trading_end)
stock2_data <- download_stock_data(symbol2, formation_start, trading_end)
View(stock1_data)
View(stock2_data)
if (is.null(stock1_data) || is.null(stock2_data)) {
return(NULL) # Exit if data download fails
}
# Convert to data frames for easier manipulation
stock1_df <- as.data.frame(stock1_data) %>% mutate(Date = ymd(rownames(.)))
stock2_df <- as.data.frame(stock2_data) %>% mutate(Date = ymd(rownames(.)))
# 2. Calculate Cumulative Returns (Formation Period)
stock1_df_formation <- stock1_df %>% filter(Date >= ymd(formation_start) & Date <= ymd(formation_end))
stock1_df_formation$Return <- (Cl(stock1_data[stock1_df_formation$Date]) - lag(Cl(stock1_data[stock1_df_formation$Date]))) / lag(Cl(stock1_data[stock1_df_formation$Date]))
stock1_df_formation$Return[is.na(stock1_df_formation$Return)] <- 0  # Handle first day
stock1_df_formation$Cumulative_Return <- cumprod(1 + stock1_df_formation$Return)
stock2_df_formation <- stock2_df %>% filter(Date >= ymd(formation_start) & Date <= ymd(formation_end))
stock2_df_formation$Return <- (Cl(stock2_data[stock2_df_formation$Date]) - lag(Cl(stock2_data[stock2_df_formation$Date]))) / lag(Cl(stock2_data[stock2_df_formation$Date]))
stock2_df_formation$Return[is.na(stock2_df_formation$Return)] <- 0  # Handle first day
stock2_df_formation$Cumulative_Return <- cumprod(1 + stock2_df_formation$Return)
stock1_df_formation$Normalized_Price <- stock1_df_formation$Cumulative_Return
stock2_df_formation$Normalized_Price <- stock2_df_formation$Cumulative_Return
par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))  # This sets the margins
plot(stock1_df_formation$Normalized_Price, col="black")
par(mfrow = c(1, 1))  # This resets the margins
plot(stock1_df_formation$Normalized_Price, col="black")
#plot(stock2_df_formation$Normalized_Price)
lines(stock2_df_formation$Normalized_Price,col="blue")
legend("topright", legend=c("HDFCNIFETF.NS-HDFC", "NIFTY1.NS-KOTAK"),
col=c("black", "blue"), lty=1, lwd=2)
# there should be one more step as sum of square of difference SSD of normalized prices
# it should be used to find the candidate pairs with minimum SSD
# 4. Calculate Spread and Historical Standard Deviation (Formation Period)
spread_formation <- stock1_df_formation$Normalized_Price - stock2_df_formation$Normalized_Price
historical_sd <- sd(spread_formation, na.rm=TRUE)
# 5. Trading Period
stock1_df_trading <- stock1_df %>% filter(Date >= ymd(trading_start) & Date <= ymd(trading_end))
stock1_df_trading$Return <- (Cl(stock1_data[stock1_df_trading$Date]) - lag(Cl(stock1_data[stock1_df_trading$Date]))) / lag(Cl(stock1_data[stock1_df_trading$Date]))
stock1_df_trading$Return[is.na(stock1_df_trading$Return)] <- 0  # Handle first day
stock1_df_trading$Cumulative_Return <- cumprod(1 + stock1_df_trading$Return)
stock2_df_trading <- stock2_df %>% filter(Date >= ymd(trading_start) & Date <= ymd(trading_end))
stock2_df_trading$Return <- (Cl(stock2_data[stock2_df_trading$Date]) - lag(Cl(stock2_data[stock2_df_trading$Date]))) / lag(Cl(stock2_data[stock2_df_trading$Date]))
stock2_df_trading$Return[is.na(stock2_df_trading$Return)] <- 0  # Handle first day
stock2_df_trading$Cumulative_Return <- cumprod(1 + stock2_df_trading$Return)
stock1_df_trading$Normalized_Price <- stock1_df_trading$Cumulative_Return
stock2_df_trading$Normalized_Price <- stock2_df_trading$Cumulative_Return
trading_decisions <- data.frame(Date = stock1_df_trading$Date, Action = character(nrow(stock1_df_trading)), Return=numeric(nrow(stock1_df_trading)), stringsAsFactors = FALSE)
View(trading_decisions)
position_open <- FALSE # Flag to track if a position is open
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Store the type of open position
for (i in 2:nrow(stock1_df_trading)) {
spread <- stock1_df_trading$Normalized_Price[i] - stock2_df_trading$Normalized_Price[i]
print(paste("spread = ", spread, " position_open=", position_open, " Date=", stock1_df_trading$Date[i],
" position_type=",position_type))
# Open Trade
if (!position_open && abs(spread) > 2 * historical_sd) {
if (spread > 0) {
trading_decisions$Action[i] <- "Short Stock 1, Long Stock 2"
position_type <- "Short Stock 1, Long Stock 2" # Store position type
} else {
trading_decisions$Action[i] <- "Long Stock 1, Short Stock 2"
position_type <- "Long Stock 1, Short Stock 2" # Store position type
}
open_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
open_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
position_open <- TRUE
open_date <- stock1_df_trading$Date[i]
}
# Close Trade (Spread Crossing or End of Trading Period)
if (position_open && (abs(spread) < historical_sd / 2 || i == nrow(stock1_df_trading))) { # Close if spread gets close to zero or last day
trading_decisions$Action[i] <- "Close Position"
close_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
close_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
# Calculate daily strategy return
return_val <- NA
if (position_type == "Short Stock 1, Long Stock 2") { # Use stored position type
return_val <- ((open_price_stock1 - close_price_stock1)/open_price_stock1) + ((close_price_stock2 - open_price_stock2)/open_price_stock2)
} else if (position_type == "Long Stock 1, Short Stock 2") { # Use stored position type
return_val <- ((close_price_stock1 - open_price_stock1)/open_price_stock1) + ((open_price_stock2 - close_price_stock2)/open_price_stock2)
}
print(paste("close_price_stock1=", close_price_stock1," open_price_stock1=", open_price_stock1))
print(paste("close_price_stock2=", close_price_stock2," open_price_stock2=", open_price_stock2))
print((open_price_stock1 - close_price_stock1)/open_price_stock1)
trading_decisions$Return[i] <- return_val
#daily_strategy_return <- append(daily_strategy_return, return_val)
position_open <- FALSE # Reset position flag
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Reset position type  <--- This is crucial!
} else if (position_open){ # If trade is open but not closed
#daily_strategy_return <- append(daily_strategy_return, 0) # Append 0 to the vector
trading_decisions$Return[i] <- 0.00
}
}
View(trading_decisions)
lines(trading_decisions$Action,col="blue")
View(trading_decisions)
View(stock2_df_trading)
View(stock2_df_formation)
View(stock2_df)
View(stock2_data)
View(stock1_df_trading)
View(spread)
View(spread_formation)
for (i in 2:nrow(stock1_df_trading)) {
spread <- stock1_df_trading$Normalized_Price[i] - stock2_df_trading$Normalized_Price[i]
print(paste("spread = ", spread, " position_open=", position_open, " Date=", stock1_df_trading$Date[i],
" position_type=",position_type))
# Open Trade
if (!position_open && abs(spread) > 1.5 * historical_sd) {
if (spread > 0) {
trading_decisions$Action[i] <- "Short Stock 1, Long Stock 2"
position_type <- "Short Stock 1, Long Stock 2" # Store position type
} else {
trading_decisions$Action[i] <- "Long Stock 1, Short Stock 2"
position_type <- "Long Stock 1, Short Stock 2" # Store position type
}
open_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
open_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
position_open <- TRUE
open_date <- stock1_df_trading$Date[i]
}
# Close Trade (Spread Crossing or End of Trading Period)
if (position_open && (abs(spread) < historical_sd / 2 || i == nrow(stock1_df_trading))) { # Close if spread gets close to zero or last day
trading_decisions$Action[i] <- "Close Position"
close_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
close_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
# Calculate daily strategy return
return_val <- NA
if (position_type == "Short Stock 1, Long Stock 2") { # Use stored position type
return_val <- ((open_price_stock1 - close_price_stock1)/open_price_stock1) + ((close_price_stock2 - open_price_stock2)/open_price_stock2)
} else if (position_type == "Long Stock 1, Short Stock 2") { # Use stored position type
return_val <- ((close_price_stock1 - open_price_stock1)/open_price_stock1) + ((open_price_stock2 - close_price_stock2)/open_price_stock2)
}
print(paste("close_price_stock1=", close_price_stock1," open_price_stock1=", open_price_stock1))
print(paste("close_price_stock2=", close_price_stock2," open_price_stock2=", open_price_stock2))
print((open_price_stock1 - close_price_stock1)/open_price_stock1)
trading_decisions$Return[i] <- return_val
#daily_strategy_return <- append(daily_strategy_return, return_val)
position_open <- FALSE # Reset position flag
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Reset position type  <--- This is crucial!
} else if (position_open){ # If trade is open but not closed
#daily_strategy_return <- append(daily_strategy_return, 0) # Append 0 to the vector
trading_decisions$Return[i] <- 0.00
}
}
View(trading_decisions)
for (i in 2:nrow(stock1_df_trading)) {
spread <- stock1_df_trading$Normalized_Price[i] - stock2_df_trading$Normalized_Price[i]
print(paste("spread = ", spread, " position_open=", position_open, " Date=", stock1_df_trading$Date[i],
" position_type=",position_type))
# Open Trade
if (!position_open && abs(spread) > 1 * historical_sd) {
if (spread > 0) {
trading_decisions$Action[i] <- "Short Stock 1, Long Stock 2"
position_type <- "Short Stock 1, Long Stock 2" # Store position type
} else {
trading_decisions$Action[i] <- "Long Stock 1, Short Stock 2"
position_type <- "Long Stock 1, Short Stock 2" # Store position type
}
open_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
open_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
position_open <- TRUE
open_date <- stock1_df_trading$Date[i]
}
# Close Trade (Spread Crossing or End of Trading Period)
if (position_open && (abs(spread) < historical_sd / 2 || i == nrow(stock1_df_trading))) { # Close if spread gets close to zero or last day
trading_decisions$Action[i] <- "Close Position"
close_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
close_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
# Calculate daily strategy return
return_val <- NA
if (position_type == "Short Stock 1, Long Stock 2") { # Use stored position type
return_val <- ((open_price_stock1 - close_price_stock1)/open_price_stock1) + ((close_price_stock2 - open_price_stock2)/open_price_stock2)
} else if (position_type == "Long Stock 1, Short Stock 2") { # Use stored position type
return_val <- ((close_price_stock1 - open_price_stock1)/open_price_stock1) + ((open_price_stock2 - close_price_stock2)/open_price_stock2)
}
print(paste("close_price_stock1=", close_price_stock1," open_price_stock1=", open_price_stock1))
print(paste("close_price_stock2=", close_price_stock2," open_price_stock2=", open_price_stock2))
print((open_price_stock1 - close_price_stock1)/open_price_stock1)
trading_decisions$Return[i] <- return_val
#daily_strategy_return <- append(daily_strategy_return, return_val)
position_open <- FALSE # Reset position flag
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Reset position type  <--- This is crucial!
} else if (position_open){ # If trade is open but not closed
#daily_strategy_return <- append(daily_strategy_return, 0) # Append 0 to the vector
trading_decisions$Return[i] <- 0.00
}
}
View(trading_decisions)
rm(list = ls())
symbol1 <- "ASIANPAINT.NS" #"HDFCNIFETF.NS" # Example: SBI Nifty 50 ETF
symbol2 <- "BHARTIARTL.NS" #"NIFTY1.NS" # Example: Nippon India ETF Nifty 50 BeES
formation_start <- "2022-01-01"
formation_end <- "2022-12-31"
trading_start <- "2023-01-01"
trading_end <- "2023-06-30"
# 1. Download Data
stock1_data <- download_stock_data(symbol1, formation_start, trading_end)
# 1. Download Data
stock1_data <- download_stock_data(symbol1, formation_start, trading_end)
download_stock_data <- function(symbol, start_date, end_date) {
tryCatch({
data <- getSymbols(symbol, from = start_date, to = end_date, auto.assign = FALSE)
if (is.null(data) || nrow(data) == 0) {
print(paste("No data found for symbol", symbol, "within the specified date range."))
return(NULL)
}
return(data)
}, error = function(e) {
print(paste("Error downloading data for", symbol, ":", e$message))
return(NULL)
})
}
## Get present location
LOC_CODE = dirname(rstudioapi::getSourceEditorContext()$path)
print(LOC_CODE)
## Set it as current working directory
setwd(LOC_CODE)
symbol1 <- "ASIANPAINT.NS" #"HDFCNIFETF.NS" # Example: SBI Nifty 50 ETF
symbol2 <- "BHARTIARTL.NS" #"NIFTY1.NS" # Example: Nippon India ETF Nifty 50 BeES
formation_start <- "2022-01-01"
formation_end <- "2022-12-31"
trading_start <- "2023-01-01"
trading_end <- "2023-06-30"
# 1. Download Data
stock1_data <- download_stock_data(symbol1, formation_start, trading_end)
stock2_data <- download_stock_data(symbol2, formation_start, trading_end)
if (is.null(stock1_data) || is.null(stock2_data)) {
return(NULL) # Exit if data download fails
}
# Convert to data frames for easier manipulation
stock1_df <- as.data.frame(stock1_data) %>% mutate(Date = ymd(rownames(.)))
stock2_df <- as.data.frame(stock2_data) %>% mutate(Date = ymd(rownames(.)))
# 2. Calculate Cumulative Returns (Formation Period)
stock1_df_formation <- stock1_df %>% filter(Date >= ymd(formation_start) & Date <= ymd(formation_end))
stock1_df_formation$Return <- (Cl(stock1_data[stock1_df_formation$Date]) - lag(Cl(stock1_data[stock1_df_formation$Date]))) / lag(Cl(stock1_data[stock1_df_formation$Date]))
stock1_df_formation$Return[is.na(stock1_df_formation$Return)] <- 0  # Handle first day
stock1_df_formation$Cumulative_Return <- cumprod(1 + stock1_df_formation$Return)
stock2_df_formation <- stock2_df %>% filter(Date >= ymd(formation_start) & Date <= ymd(formation_end))
stock2_df_formation$Return <- (Cl(stock2_data[stock2_df_formation$Date]) - lag(Cl(stock2_data[stock2_df_formation$Date]))) / lag(Cl(stock2_data[stock2_df_formation$Date]))
stock2_df_formation$Return[is.na(stock2_df_formation$Return)] <- 0  # Handle first day
stock2_df_formation$Cumulative_Return <- cumprod(1 + stock2_df_formation$Return)
stock1_df_formation$Normalized_Price <- stock1_df_formation$Cumulative_Return
stock2_df_formation$Normalized_Price <- stock2_df_formation$Cumulative_Return
par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))  # This sets the margins
plot(stock1_df_formation$Normalized_Price, col="black")
par(mfrow = c(1, 1))  # This resets the margins
plot(stock1_df_formation$Normalized_Price, col="black")
#plot(stock2_df_formation$Normalized_Price)
lines(stock2_df_formation$Normalized_Price,col="blue")
legend("topright", legend=c("HDFCNIFETF.NS-HDFC", "NIFTY1.NS-KOTAK"),
col=c("black", "blue"), lty=1, lwd=2)
par(mfrow = c(1, 1))  # This resets the margins
# there should be one more step as sum of square of difference SSD of normalized prices
# it should be used to find the candidate pairs with minimum SSD
# 4. Calculate Spread and Historical Standard Deviation (Formation Period)
spread_formation <- stock1_df_formation$Normalized_Price - stock2_df_formation$Normalized_Price
historical_sd <- sd(spread_formation, na.rm=TRUE)
# 5. Trading Period
stock1_df_trading <- stock1_df %>% filter(Date >= ymd(trading_start) & Date <= ymd(trading_end))
stock1_df_trading$Return <- (Cl(stock1_data[stock1_df_trading$Date]) - lag(Cl(stock1_data[stock1_df_trading$Date]))) / lag(Cl(stock1_data[stock1_df_trading$Date]))
stock1_df_trading$Return[is.na(stock1_df_trading$Return)] <- 0  # Handle first day
stock1_df_trading$Cumulative_Return <- cumprod(1 + stock1_df_trading$Return)
stock2_df_trading <- stock2_df %>% filter(Date >= ymd(trading_start) & Date <= ymd(trading_end))
stock2_df_trading$Return <- (Cl(stock2_data[stock2_df_trading$Date]) - lag(Cl(stock2_data[stock2_df_trading$Date]))) / lag(Cl(stock2_data[stock2_df_trading$Date]))
stock2_df_trading$Return[is.na(stock2_df_trading$Return)] <- 0  # Handle first day
stock2_df_trading$Cumulative_Return <- cumprod(1 + stock2_df_trading$Return)
stock1_df_trading$Normalized_Price <- stock1_df_trading$Cumulative_Return
stock2_df_trading$Normalized_Price <- stock2_df_trading$Cumulative_Return
trading_decisions <- data.frame(Date = stock1_df_trading$Date, Action = character(nrow(stock1_df_trading)), Return=numeric(nrow(stock1_df_trading)), stringsAsFactors = FALSE)
position_open <- FALSE # Flag to track if a position is open
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Store the type of open position
for (i in 2:nrow(stock1_df_trading)) {
spread <- stock1_df_trading$Normalized_Price[i] - stock2_df_trading$Normalized_Price[i]
print(paste("spread = ", spread, " position_open=", position_open, " Date=", stock1_df_trading$Date[i],
" position_type=",position_type))
# Open Trade
if (!position_open && abs(spread) > 2 * historical_sd) {
if (spread > 0) {
trading_decisions$Action[i] <- "Short Stock 1, Long Stock 2"
position_type <- "Short Stock 1, Long Stock 2" # Store position type
} else {
trading_decisions$Action[i] <- "Long Stock 1, Short Stock 2"
position_type <- "Long Stock 1, Short Stock 2" # Store position type
}
open_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
open_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
position_open <- TRUE
open_date <- stock1_df_trading$Date[i]
}
# Close Trade (Spread Crossing or End of Trading Period)
if (position_open && (abs(spread) < historical_sd / 2 || i == nrow(stock1_df_trading))) { # Close if spread gets close to zero or last day
trading_decisions$Action[i] <- "Close Position"
close_price_stock1 <- as.numeric(Cl(stock1_data[stock1_df_trading$Date[i]]))
close_price_stock2 <- as.numeric(Cl(stock2_data[stock2_df_trading$Date[i]]))
# Calculate daily strategy return
return_val <- NA
if (position_type == "Short Stock 1, Long Stock 2") { # Use stored position type
return_val <- ((open_price_stock1 - close_price_stock1)/open_price_stock1) + ((close_price_stock2 - open_price_stock2)/open_price_stock2)
} else if (position_type == "Long Stock 1, Short Stock 2") { # Use stored position type
return_val <- ((close_price_stock1 - open_price_stock1)/open_price_stock1) + ((open_price_stock2 - close_price_stock2)/open_price_stock2)
}
print(paste("close_price_stock1=", close_price_stock1," open_price_stock1=", open_price_stock1))
print(paste("close_price_stock2=", close_price_stock2," open_price_stock2=", open_price_stock2))
print((open_price_stock1 - close_price_stock1)/open_price_stock1)
trading_decisions$Return[i] <- return_val
#daily_strategy_return <- append(daily_strategy_return, return_val)
position_open <- FALSE # Reset position flag
open_price_stock1 <- NA
open_price_stock2 <- NA
open_date <- NA
position_type <- "" # Reset position type  <--- This is crucial!
} else if (position_open){ # If trade is open but not closed
#daily_strategy_return <- append(daily_strategy_return, 0) # Append 0 to the vector
trading_decisions$Return[i] <- 0.00
}
}
View(trading_decisions)
View(stock2_df_trading)
